#pragma once

#include <core/defines.h>

/*
    @file logger.h
    @brief Система логирования с поддержкой различных уровней важности сообщений.

    Система предоставляет:
    - Шесть уровней логирования (от FATAL до TRACE), по умолчанию уровень логирования ERROR
    - Возможность установки пользовательских обработчиков
    - Фильтрацию по уровню важности
    - Поддержку форматированных сообщений
    - Автоматическое добавление метаданных (файл, строка, время)
*/

// @brief Уровни важности сообщений системы логирования.
typedef enum log_level {
    /*
        @brief Критическая ошибка, после которой система не может продолжать работу.
               Требует немедленного вмешательства.
    */
    LOG_LEVEL_FATAL,
    /*
        @brief Ошибка в работе системы, но система может продолжать работу.
               Требует внимания разработчика.
    */
    LOG_LEVEL_ERROR,
    /*
        @brief Предупреждение о потенциальной проблеме.
               Система работает нормально, но есть необычные условия.
    */
    LOG_LEVEL_WARN,
    /*
        @brief Информационное сообщение о нормальной работе системы.
               Используется для основных событий в работе приложения.
    */
    LOG_LEVEL_INFO,
    /*
        @brief Отладочная информация для разработчиков.
               Используется при отладке проблем.
    */
    LOG_LEVEL_DEBUG,
    /*
        @brief Детальная отладочная информация.
               Может содержать частые или объемные сообщения.
    */
    LOG_LEVEL_TRACE,
    /*
        @brief Количество уровней логирования (не является реальным уровнем).
    */
    LOG_LEVEL_COUNT
} log_level;

// @brief Структура, содержащая полную информацию о сообщении лога.
typedef struct log_message {
    // @brief Уровень важности сообщения.
    log_level level;
    // @brief Имя исходного файла, из которого было отправлено сообщение.
    const char* filename;
    // @brief Длина имени исходного файла в байтах.
    u32 filename_length;
    // @brief Номер строки в исходном файле.
    u32 fileline;
    // @brief Текст сообщения после форматирования.
    const char* message;
    // @brief Размер текстового сообщения.
    u32 message_length;
    // @brief Временная метка сообщения в секундах с 1970-01-01.
    u64 timestamp;
} log_message;

/*
    @brief Тип функции-обработчика сообщений лога.
    @param message Структура с информацией о сообщении.
    @param user_data Пользовательские данные, переданные при регистрации обработчика.
*/
typedef void (*log_handler_pfn)(const log_message message, const void* user_data);

/*
    @brief Устанавливает минимальный уровень логирования.
    @note По умолчанию уровень логирования ERROR.
    @note Сообщения FATAL и ERROR всегда логируются и не могут быть отключены.
    @param level Минимальный уровень логирования (сообщения ниже этого уровня игнорируются).
*/
API void log_set_level(log_level level);

/*
    @brief Регистрирует пользовательский обработчик сообщений лога.
    @param handler Указатель на функцию-обработчик. Если nullptr, логирование отключается.
    @param user_data Пользовательские данные, которые будут переданы в обработчик.
           Может быть nullptr, если данные не требуются.
*/
API void log_set_handler(log_handler_pfn handler, const void* user_data);

/*
    @brief Восстанавливает обработчик логов по умолчанию.
    @note Обработчик по умолчанию выводит сообщения в stdout (для INFO, DEBUG, TRACE).
    @note Обработчик по умолчанию выводит сообщения в stderr (для FATAL, ERROR, WARN).
*/
API void log_reset_default_handler();

/*
    @brief Основная функция для записи сообщений в лог.
    @note Обычно используется через макросы LOG_.
    @param level Уровень важности сообщения.
    @param filename Имя исходного файла (обычно __FILE__ или __FILE_NAME__).
    @param fileline Номер строки исходного файла (обычно __LINE__).
    @param format Строка формата (может быть просто сообщением).
    @param ... Аргументы строки формата (опционально).
*/
API void log_write(log_level level, const char* filename, u32 fileline, const char* format, ...);

/*
    @brief Макрос для логирования сообщений уровня FATAL.
    @note Используется для критических ошибок, после которых работа системы невозможна.
*/
#define LOG_FATAL(...) log_write(LOG_LEVEL_FATAL, __FILE_NAME__, __LINE__, __VA_ARGS__)

/*
    @brief Макрос для логирования сообщений уровня ERROR.
    @note Используется для ошибок, которые позволяют системе продолжать работу.
*/
#define LOG_ERROR(...) log_write(LOG_LEVEL_ERROR, __FILE_NAME__, __LINE__, __VA_ARGS__)

/*
    @brief Макрос для логирования сообщений уровня WARN.
    @note Используется для предупреждений о потенциальных проблемах.
*/
#define LOG_WARN(...) log_write(LOG_LEVEL_WARN, __FILE_NAME__, __LINE__, __VA_ARGS__)

/*
    @brief Макрос для логирования сообщений уровня INFO.
    @note Используется для информационных сообщений о нормальной работе системы.
*/
#define LOG_INFO(...) log_write(LOG_LEVEL_INFO, __FILE_NAME__, __LINE__, __VA_ARGS__)

#if DEBUG_FLAG
    /*
        @brief Макрос для логирования сообщений уровня DEBUG.
        @note Используется только в отладочных сборках для диагностики проблем.
    */
    #define LOG_DEBUG(...) log_write(LOG_LEVEL_DEBUG, __FILE_NAME__, __LINE__, __VA_ARGS__)

    /*
        @brief Макрос для логирования сообщений уровня TRACE.
        @note Используется только в отладочных сборках для детальной диагностики.
        @note Может генерировать очень много сообщений.
    */
    #define LOG_TRACE(...) log_write(LOG_LEVEL_TRACE, __FILE_NAME__, __LINE__, __VA_ARGS__)
#else
    // В релизных сборках отладочные макросы не производят никаких действий.
    #define LOG_DEBUG(...) ((void)0)
    #define LOG_TRACE(...) ((void)0)
#endif
