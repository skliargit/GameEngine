/*
    @file logger.h
    @brief Интерфейс системы логирования с поддержкой различных уровней важности сообщений.
    @author Дмитрий Скляр.
    @version 1.1
    @date 27-08-2025

    @license Лицензия Apache, версия 2.0 («Лицензия»);
          Вы не имеете права использовать этот файл без соблюдения условий Лицензии.
          Копию Лицензии можно получить по адресу http://www.apache.org/licenses/LICENSE-2.0
          Если иное не предусмотрено действующим законодательством или не согласовано в письменной форме,
          программное обеспечение, распространяемое по Лицензии, распространяется на условиях «КАК ЕСТЬ»,
          БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ ИЛИ УСЛОВИЙ, явных или подразумеваемых. См. Лицензию для получения
          информации о конкретных языках, регулирующих разрешения и ограничения по Лицензии.

    @note Система предоставляет:
            - Шесть уровней логирования (от FATAL до TRACE)
            - Возможность установки пользовательских обработчиков
            - Фильтрацию по уровню важности
            - Поддержку форматированных сообщений
            - Автоматическое добавление метаданных (файл, строка, время, уровень)

    @note Уровень логирования по умолчанию:
            - В отладочной сборке (DEBUG): LOG_LEVEL_TRACE
            - В релизной сборке (RELEASE): LOG_LEVEL_ERROR

    @note Для корректной работы необходимо предварительно инициализировать (в указанном порядке):
            - Подсистему консоли platform_console_initialize()
            - Подсистему памяти platform_memory_initialize()
*/

#pragma once

#include <core/defines.h>

// @brief Уровни важности сообщений системы логирования.
typedef enum log_level {
    /*
        @brief Критическая ошибка, после которой система не может продолжать работу.
               Требует немедленного вмешательства.
    */
    LOG_LEVEL_FATAL,
    /*
        @brief Ошибка в работе системы, но система может продолжать работу.
               Требует внимания разработчика.
    */
    LOG_LEVEL_ERROR,
    /*
        @brief Предупреждение о потенциальной проблеме.
               Система работает нормально, но есть необычные условия.
    */
    LOG_LEVEL_WARN,
    /*
        @brief Информационное сообщение о нормальной работе системы.
               Используется для основных событий в работе приложения.
    */
    LOG_LEVEL_INFO,
    /*
        @brief Отладочная информация для разработчиков.
               Используется при отладке проблем.
    */
    LOG_LEVEL_DEBUG,
    /*
        @brief Детальная отладочная информация.
               Может содержать частые или объемные сообщения.
    */
    LOG_LEVEL_TRACE,
    /*
        @brief Количество уровней логирования (не является реальным уровнем).
    */
    LOG_LEVEL_COUNT
} log_level;

// @brief Структура, содержащая полную информацию о сообщении лога.
typedef struct log_message {
    // @brief Уровень важности сообщения.
    log_level level;
    // @brief Имя исходного файла, из которого было отправлено сообщение.
    const char* filename;
    // @brief Длина имени исходного файла в байтах.
    u32 filename_length;
    // @brief Номер строки в исходном файле.
    u32 fileline;
    // @brief Текст сообщения после форматирования.
    const char* message;
    // @brief Размер текстового сообщения.
    u32 message_length;
    // @brief Временная метка сообщения в секундах с 1970-01-01.
    u64 timestamp;
} log_message;

/*
    @brief Callback-функция, обработчика сообщений лога.
    @note Обработчик вызывается для каждого сообщения, прошедшего фильтрацию по уровню.
    @param message Структура с информацией о сообщении лога.
    @param user_data Пользовательские данные, переданные при регистрации обработчика.
*/
typedef void (*log_handler_callback)(const log_message message, const void* user_data);

/*
    @brief Устанавливает минимальный уровень логирования.
    @note По умолчанию уровень логирования ERROR.
    @note Сообщения FATAL и ERROR всегда логируются и не могут быть отключены.
    @param level Минимальный уровень логирования (сообщения ниже этого уровня игнорируются).
*/
API void log_set_level(log_level level);

/*
    @brief Регистрирует пользовательский обработчик сообщений лога.
    @param handler Указатель на функцию-обработчик. Если nullptr, логирование отключается.
    @param user_data Пользовательские данные, которые будут переданы в обработчик.
           Может быть nullptr, если данные не требуются.
*/
API void log_set_handler(log_handler_callback handler, const void* user_data);

/*
    @brief Восстанавливает обработчик логов по умолчанию.
    @note Обработчик по умолчанию выводит сообщения в stdout (для INFO, DEBUG, TRACE).
    @note Обработчик по умолчанию выводит сообщения в stderr (для FATAL, ERROR, WARN).
*/
API void log_reset_default_handler();

/*
    @brief Основная функция для записи сообщений в лог.
    @note Обычно используется через макросы LOG_.
    @param level Уровень важности сообщения.
    @param filename Имя исходного файла (обычно __FILE__ или __FILE_NAME__).
    @param fileline Номер строки исходного файла (обычно __LINE__).
    @param format Строка формата (может быть просто сообщением).
    @param ... Аргументы строки формата (опционально).
*/
API void log_write(log_level level, const char* filename, u32 fileline, const char* format, ...);

/*
    @brief Макрос для логирования сообщений уровня FATAL.
    @note Используется для критических ошибок, после которых работа системы невозможна.
*/
#define LOG_FATAL(...) log_write(LOG_LEVEL_FATAL, __FILE_NAME__, __LINE__, __VA_ARGS__)

/*
    @brief Макрос для логирования сообщений уровня ERROR.
    @note Используется для ошибок, которые позволяют системе продолжать работу.
*/
#define LOG_ERROR(...) log_write(LOG_LEVEL_ERROR, __FILE_NAME__, __LINE__, __VA_ARGS__)

/*
    @brief Макрос для логирования сообщений уровня WARN.
    @note Используется для предупреждений о потенциальных проблемах.
*/
#define LOG_WARN(...) log_write(LOG_LEVEL_WARN, __FILE_NAME__, __LINE__, __VA_ARGS__)

/*
    @brief Макрос для логирования сообщений уровня INFO.
    @note Используется для информационных сообщений о нормальной работе системы.
*/
#define LOG_INFO(...) log_write(LOG_LEVEL_INFO, __FILE_NAME__, __LINE__, __VA_ARGS__)

#if DEBUG_FLAG
    /*
        @brief Макрос для логирования сообщений уровня DEBUG.
        @note Используется только в отладочных сборках для диагностики проблем.
    */
    #define LOG_DEBUG(...) log_write(LOG_LEVEL_DEBUG, __FILE_NAME__, __LINE__, __VA_ARGS__)

    /*
        @brief Макрос для логирования сообщений уровня TRACE.
        @note Используется только в отладочных сборках для детальной диагностики.
        @note Может генерировать очень много сообщений.
    */
    #define LOG_TRACE(...) log_write(LOG_LEVEL_TRACE, __FILE_NAME__, __LINE__, __VA_ARGS__)
#else
    /*
        @brief Макрос для логирования сообщений уровня DEBUG.
        @note Используется только в отладочных сборках для диагностики проблем.
    */
    #define LOG_DEBUG(...) UNUSED(0)

    /*
        @brief Макрос для логирования сообщений уровня TRACE.
        @note Используется только в отладочных сборках для детальной диагностики.
        @note Может генерировать очень много сообщений.
    */
    #define LOG_TRACE(...) UNUSED(0)
#endif
